(self.webpackChunkmetaverse_experience=self.webpackChunkmetaverse_experience||[]).push([[72],{6072:(e,t,n)=>{var i=n(744),r=n(7186),o=function(){var e,t,n,i,o=new r.Vector3;function s(){this.tolerance=-1,this.faces=[],this.newFaces=[],this.assigned=new c,this.unassigned=new c,this.vertices=[]}function a(){this.normal=new r.Vector3,this.midpoint=new r.Vector3,this.area=0,this.constant=0,this.outside=null,this.mark=0,this.edge=null}function u(e,t){this.vertex=e,this.prev=null,this.next=null,this.twin=null,this.face=t}function h(e,t){this.point=e,this.index=t,this.prev=null,this.next=null,this.face=null}function c(){this.head=null,this.tail=null}return Object.assign(s.prototype,{toJSON:function(){const e=this.faces.map((e=>e.toArray())),t=Array.from(new Set(e.flat())).sort(),n=[];for(let e=0;e<t.length;e++)n.push(this.vertices[t[e]].point.x,this.vertices[t[e]].point.y,this.vertices[t[e]].point.z);const i=new Map;for(let e=0;e<t.length;e++)i.set(t[e],e);const r=[];for(let t=0;t<e.length;t++)r.push([i.get(e[t][0]),i.get(e[t][1]),i.get(e[t][2])]);return[n,r]},setFromPoints:function(e){!0!==Array.isArray(e)&&console.error("THREE.ConvexHull: Points parameter is not an array."),e.length<4&&console.error("THREE.ConvexHull: The algorithm needs at least four points."),this.makeEmpty();for(var t=0,n=e.length;t<n;t++)this.vertices.push(new h(e[t],t));return this.compute(),this},setFromObject:function(e){var t=[];return e.updateMatrixWorld(!0),e.traverse((function(e){var n,i,o,s=e.geometry;if(void 0!==s&&(s.isGeometry&&(s=s.toBufferGeometry?s.toBufferGeometry():(new BufferGeometry).fromGeometry(s)),s.isBufferGeometry)){var a=s.attributes.position;if(void 0!==a)for(n=0,i=a.count;n<i;n++)(o=new r.Vector3).fromBufferAttribute(a,n).applyMatrix4(e.matrixWorld),t.push(o)}})),this.setFromPoints(t)},containsPoint:function(e){for(var t=this.faces,n=0,i=t.length;n<i;n++){if(t[n].distanceToPoint(e)>this.tolerance)return!1}return!0},intersectRay:function(e,t){for(var n=this.faces,i=-1/0,r=1/0,o=0,s=n.length;o<s;o++){var a=n[o],u=a.distanceToPoint(e.origin),h=a.normal.dot(e.direction);if(u>0&&h>=0)return null;var c=0!==h?-u/h:0;if(!(c<=0)&&(h>0?r=Math.min(c,r):i=Math.max(c,i),i>r))return null}return i!==-1/0?e.at(i,t):e.at(r,t),t},intersectsRay:function(e){return null!==this.intersectRay(e,o)},makeEmpty:function(){return this.faces=[],this.vertices=[],this},addVertexToFace:function(e,t){return e.face=t,null===t.outside?this.assigned.append(e):this.assigned.insertBefore(t.outside,e),t.outside=e,this},removeVertexFromFace:function(e,t){return e===t.outside&&(null!==e.next&&e.next.face===t?t.outside=e.next:t.outside=null),this.assigned.remove(e),this},removeAllVerticesFromFace:function(e){if(null!==e.outside){for(var t=e.outside,n=e.outside;null!==n.next&&n.next.face===e;)n=n.next;return this.assigned.removeSubList(t,n),t.prev=n.next=null,e.outside=null,t}},deleteFaceVertices:function(e,t){var n=this.removeAllVerticesFromFace(e);if(void 0!==n)if(void 0===t)this.unassigned.appendChain(n);else{var i=n;do{var r=i.next;t.distanceToPoint(i.point)>this.tolerance?this.addVertexToFace(i,t):this.unassigned.append(i),i=r}while(null!==i)}return this},resolveUnassignedPoints:function(e){if(!1===this.unassigned.isEmpty()){var t=this.unassigned.first();do{for(var n=t.next,i=this.tolerance,r=null,o=0;o<e.length;o++){var s=e[o];if(0===s.mark){var a=s.distanceToPoint(t.point);if(a>i&&(i=a,r=s),i>1e3*this.tolerance)break}}null!==r&&this.addVertexToFace(t,r),t=n}while(null!==t)}return this},computeExtremes:function(){var e,t,n,i=new r.Vector3,o=new r.Vector3,s=[],a=[];for(e=0;e<3;e++)s[e]=a[e]=this.vertices[0];for(i.copy(this.vertices[0].point),o.copy(this.vertices[0].point),e=0,t=this.vertices.length;e<t;e++){var u=this.vertices[e],h=u.point;for(n=0;n<3;n++)h.getComponent(n)<i.getComponent(n)&&(i.setComponent(n,h.getComponent(n)),s[n]=u);for(n=0;n<3;n++)h.getComponent(n)>o.getComponent(n)&&(o.setComponent(n,h.getComponent(n)),a[n]=u)}return this.tolerance=3*Number.EPSILON*(Math.max(Math.abs(i.x),Math.abs(o.x))+Math.max(Math.abs(i.y),Math.abs(o.y))+Math.max(Math.abs(i.z),Math.abs(o.z))),{min:s,max:a}},computeInitialHull:function(){void 0===e&&(e=new r.Line3,t=new r.Plane,n=new r.Vector3);var i,o,s,u,h,c,l,p,f,d=this.vertices,m=this.computeExtremes(),g=m.min,x=m.max,y=0,v=0;for(c=0;c<3;c++)(f=x[c].point.getComponent(c)-g[c].point.getComponent(c))>y&&(y=f,v=c);for(o=g[v],s=x[v],y=0,e.set(o.point,s.point),c=0,l=this.vertices.length;c<l;c++)(i=d[c])!==o&&i!==s&&(e.closestPointToPoint(i.point,!0,n),(f=n.distanceToSquared(i.point))>y&&(y=f,u=i));for(y=-1,t.setFromCoplanarPoints(o.point,s.point,u.point),c=0,l=this.vertices.length;c<l;c++)(i=d[c])!==o&&i!==s&&i!==u&&(f=Math.abs(t.distanceToPoint(i.point)))>y&&(y=f,h=i);var w=[];if(t.distanceToPoint(h.point)<0)for(w.push(a.create(o,s,u),a.create(h,s,o),a.create(h,u,s),a.create(h,o,u)),c=0;c<3;c++)p=(c+1)%3,w[c+1].getEdge(2).setTwin(w[0].getEdge(p)),w[c+1].getEdge(1).setTwin(w[p+1].getEdge(0));else for(w.push(a.create(o,u,s),a.create(h,o,s),a.create(h,s,u),a.create(h,u,o)),c=0;c<3;c++)p=(c+1)%3,w[c+1].getEdge(2).setTwin(w[0].getEdge((3-c)%3)),w[c+1].getEdge(0).setTwin(w[p+1].getEdge(1));for(c=0;c<4;c++)this.faces.push(w[c]);for(c=0,l=d.length;c<l;c++)if((i=d[c])!==o&&i!==s&&i!==u&&i!==h){y=this.tolerance;var T=null;for(p=0;p<4;p++)(f=this.faces[p].distanceToPoint(i.point))>y&&(y=f,T=this.faces[p]);null!==T&&this.addVertexToFace(i,T)}return this},reindexFaces:function(){for(var e=[],t=0;t<this.faces.length;t++){var n=this.faces[t];0===n.mark&&e.push(n)}return this.faces=e,this},nextVertexToAdd:function(){if(!1===this.assigned.isEmpty()){var e,t=0,n=this.assigned.first().face,i=n.outside;do{var r=n.distanceToPoint(i.point);r>t&&(t=r,e=i),i=i.next}while(null!==i&&i.face===n);return e}},computeHorizon:function(e,t,n,i){var r;this.deleteFaceVertices(n),n.mark=1,r=null===t?t=n.getEdge(0):t.next;do{var o=r.twin,s=o.face;0===s.mark&&(s.distanceToPoint(e)>this.tolerance?this.computeHorizon(e,o,s,i):i.push(r)),r=r.next}while(r!==t);return this},addAdjoiningFace:function(e,t){var n=a.create(e,t.tail(),t.head());return this.faces.push(n),n.getEdge(-1).setTwin(t.twin),n.getEdge(0)},addNewFaces:function(e,t){this.newFaces=[];for(var n=null,i=null,r=0;r<t.length;r++){var o=t[r],s=this.addAdjoiningFace(e,o);null===n?n=s:s.next.setTwin(i),this.newFaces.push(s.face),i=s}return n.next.setTwin(i),this},addVertexToHull:function(e){var t=[];return this.unassigned.clear(),this.removeVertexFromFace(e,e.face),this.computeHorizon(e.point,null,e.face,t),this.addNewFaces(e,t),this.resolveUnassignedPoints(this.newFaces),this},cleanup:function(){return this.assigned.clear(),this.unassigned.clear(),this.newFaces=[],this},compute:function(){var e;for(this.computeInitialHull();void 0!==(e=this.nextVertexToAdd());)this.addVertexToHull(e);return this.reindexFaces(),this.cleanup(),this}}),Object.assign(a,{create:function(e,t,n){var i=new a,r=new u(e,i),o=new u(t,i),s=new u(n,i);return r.next=s.prev=o,o.next=r.prev=s,s.next=o.prev=r,i.edge=r,i.compute()}}),Object.assign(a.prototype,{toArray:function(){const e=[];let t=this.edge;do{e.push(t.head().index),t=t.next}while(t!==this.edge);return e},getEdge:function(e){for(var t=this.edge;e>0;)t=t.next,e--;for(;e<0;)t=t.prev,e++;return t},compute:function(){void 0===i&&(i=new r.Triangle);var e=this.edge.tail(),t=this.edge.head(),n=this.edge.next.head();return i.set(e.point,t.point,n.point),i.getNormal(this.normal),i.getMidpoint(this.midpoint),this.area=i.getArea(),this.constant=this.normal.dot(this.midpoint),this},distanceToPoint:function(e){return this.normal.dot(e)-this.constant}}),Object.assign(u.prototype,{head:function(){return this.vertex},tail:function(){return this.prev?this.prev.vertex:null},length:function(){var e=this.head(),t=this.tail();return null!==t?t.point.distanceTo(e.point):-1},lengthSquared:function(){var e=this.head(),t=this.tail();return null!==t?t.point.distanceToSquared(e.point):-1},setTwin:function(e){return this.twin=e,e.twin=this,this}}),Object.assign(c.prototype,{first:function(){return this.head},last:function(){return this.tail},clear:function(){return this.head=this.tail=null,this},insertBefore:function(e,t){return t.prev=e.prev,t.next=e,null===t.prev?this.head=t:t.prev.next=t,e.prev=t,this},insertAfter:function(e,t){return t.prev=e,t.next=e.next,null===t.next?this.tail=t:t.next.prev=t,e.next=t,this},append:function(e){return null===this.head?this.head=e:this.tail.next=e,e.prev=this.tail,e.next=null,this.tail=e,this},appendChain:function(e){for(null===this.head?this.head=e:this.tail.next=e,e.prev=this.tail;null!==e.next;)e=e.next;return this.tail=e,this},remove:function(e){return null===e.prev?this.head=e.next:e.prev.next=e.next,null===e.next?this.tail=e.prev:e.next.prev=e.prev,this},removeSubList:function(e,t){return null===e.prev?this.head=t.next:e.prev.next=t.next,null===t.next?this.tail=e.prev:t.next.prev=e.prev,this},isEmpty:function(){return null===this.head}}),s}();const s=new r.Vector3,a=new r.Vector3,u=new r.Quaternion;function h(e){const t=function(e){const t=[];return e.traverse((function(e){e.isMesh&&t.push(e)})),t}(e);if(0===t.length)return null;if(1===t.length)return c(t[0]);let n;const i=[];for(;n=t.pop();)i.push(f(c(n)));return function(e){let t=0;for(let n=0;n<e.length;n++){const i=e[n].attributes.position;i&&3===i.itemSize&&(t+=i.count)}const n=new Float32Array(3*t);let i=0;for(let t=0;t<e.length;t++){const r=e[t].attributes.position;if(r&&3===r.itemSize)for(let e=0;e<r.count;e++)n[i++]=r.getX(e),n[i++]=r.getY(e),n[i++]=r.getZ(e)}return(new r.BufferGeometry).setAttribute("position",new r.BufferAttribute(n,3))}(i)}function c(e){let t=e.geometry;return t=t.toBufferGeometry?t.toBufferGeometry():t.clone(),e.updateMatrixWorld(),e.matrixWorld.decompose(s,u,a),t.scale(a.x,a.y,a.z),t}function l(e){const t=e.attributes.position,n=new Float32Array(3*t.count);for(let e=0;e<t.count;e++)n[3*e]=t.getX(e),n[3*e+1]=t.getY(e),n[3*e+2]=t.getZ(e);return n}function p(e,t){switch(t){case"x":return e.x;case"y":return e.y;case"z":return e.z}throw new Error("Unexpected component "+t)}function f(e,t=1e-4){t=Math.max(t,Number.EPSILON);const n={},i=e.getIndex(),o=e.getAttribute("position"),s=i?i.count:o.count;let a=0;const u=[],h=[],c=Math.log10(1/t),l=Math.pow(10,c);for(let e=0;e<s;e++){const t=i?i.getX(e):e;let r="";r+=~~(o.getX(t)*l)+",",r+=~~(o.getY(t)*l)+",",r+=~~(o.getZ(t)*l)+",",r in n?u.push(n[r]):(h.push(o.getX(t)),h.push(o.getY(t)),h.push(o.getZ(t)),n[r]=a,u.push(a),a++)}const p=new r.BufferAttribute(new Float32Array(h),o.itemSize,o.normalized),f=new r.BufferGeometry;return f.setAttribute("position",p),f.setIndex(u),f}const d=Math.PI/2;var m;t.ShapeType=void 0,(m=t.ShapeType||(t.ShapeType={})).BOX="Box",m.CYLINDER="Cylinder",m.SPHERE="Sphere",m.HULL="ConvexPolyhedron",m.MESH="Trimesh";const g=function(e,n={}){let s;if(n.type===t.ShapeType.BOX)return y(e);if(n.type===t.ShapeType.CYLINDER)return function(e,n){const o=["x","y","z"],s=n.cylinderAxis||"y",a=o.splice(o.indexOf(s),1)&&o,u=(new r.Box3).setFromObject(e);if(!isFinite(u.min.lengthSq()))return null;const h=u.max[s]-u.min[s],c=.5*Math.max(p(u.max,a[0])-p(u.min,a[0]),p(u.max,a[1])-p(u.min,a[1])),l="y"===s?d:0,f="z"===s?d:0;return{type:t.ShapeType.CYLINDER,params:{radiusTop:c,radiusBottom:c,height:h,segments:12},orientation:(new i.Quaternion).setFromEuler(l,f,0,"XYZ").normalize()}}(e,n);if(n.type===t.ShapeType.SPHERE)return function(e,n){if(n.sphereRadius)return{type:t.ShapeType.SPHERE,params:{radius:n.sphereRadius}};const i=h(e);return i?(i.computeBoundingSphere(),{type:t.ShapeType.SPHERE,params:{radius:i.boundingSphere.radius}}):null}(e,n);if(n.type===t.ShapeType.HULL)return function(e){const n=h(e);if(!n)return null;const i=1e-4;for(let e=0;e<n.attributes.position.count;e++)n.attributes.position.setXYZ(e,n.attributes.position.getX(e)+(Math.random()-.5)*i,n.attributes.position.getY(e)+(Math.random()-.5)*i,n.attributes.position.getZ(e)+(Math.random()-.5)*i);const[s,a]=(new o).setFromObject(new r.Mesh(n)).toJSON();return{type:t.ShapeType.HULL,params:{vertices:new Float32Array(s),faces:a}}}(e);if(n.type===t.ShapeType.MESH)return s=h(e),s?function(e){const n=l(e);if(!n.length)return null;const i=new Uint32Array(n.length);for(let e=0;e<n.length;e++)i[e]=e;return{type:t.ShapeType.MESH,params:{vertices:n,indices:i}}}(s):null;if(n.type)throw new Error('[CANNON.getShapeParameters] Invalid type "'+n.type+'".');if(s=h(e),!s)return null;switch(s.type){case"BoxGeometry":case"BoxBufferGeometry":return x(s);case"CylinderGeometry":case"CylinderBufferGeometry":return function(e){const n=e.parameters;return{type:t.ShapeType.CYLINDER,params:{radiusTop:n.radiusTop,radiusBottom:n.radiusBottom,height:n.height,segments:n.radialSegments},orientation:(new i.Quaternion).setFromEuler(r.MathUtils.degToRad(-90),0,0,"XYZ").normalize()}}(s);case"PlaneGeometry":case"PlaneBufferGeometry":return function(e){e.computeBoundingBox();const n=e.boundingBox;return{type:t.ShapeType.BOX,params:{x:(n.max.x-n.min.x)/2||.1,y:(n.max.y-n.min.y)/2||.1,z:(n.max.z-n.min.z)/2||.1}}}(s);case"SphereGeometry":case"SphereBufferGeometry":return function(e){return{type:t.ShapeType.SPHERE,params:{radius:e.parameters.radius}}}(s);case"TubeGeometry":case"BufferGeometry":return y(e);default:return console.warn('Unrecognized geometry: "%s". Using bounding box as shape.',s.type),x(s)}};function x(e){if(!l(e).length)return null;e.computeBoundingBox();const n=e.boundingBox;return{type:t.ShapeType.BOX,params:{x:(n.max.x-n.min.x)/2,y:(n.max.y-n.min.y)/2,z:(n.max.z-n.min.z)/2}}}function y(e){const n=e.clone();n.quaternion.set(0,0,0,1),n.updateMatrixWorld();const o=(new r.Box3).setFromObject(n);if(!isFinite(o.min.lengthSq()))return null;const s=o.translate(n.position.negate()).getCenter(new r.Vector3);return{type:t.ShapeType.BOX,params:{x:(o.max.x-o.min.x)/2,y:(o.max.y-o.min.y)/2,z:(o.max.z-o.min.z)/2},offset:s.lengthSq()?new i.Vec3(s.x,s.y,s.z):void 0}}t.getShapeParameters=g,t.threeToCannon=function(e,n={}){const r=g(e,n);if(!r)return null;const{type:o,params:s,offset:a,orientation:u}=r;let h;return h=o===t.ShapeType.BOX?function(e){const{x:t,y:n,z:r}=e,o=new i.Box(new i.Vec3(t,n,r));return o}(s):o===t.ShapeType.CYLINDER?function(e){const{radiusTop:t,radiusBottom:n,height:r,segments:o}=e,s=new i.Cylinder(t,n,r,o);return s.radiusTop=n,s.radiusBottom=n,s.height=r,s.numSegments=o,s}(s):o===t.ShapeType.SPHERE?function(e){const t=new i.Sphere(e.radius);return t}(s):o===t.ShapeType.HULL?function(e){const{faces:t,vertices:n}=e,r=[];for(let e=0;e<n.length;e+=3)r.push(new i.Vec3(n[e],n[e+1],n[e+2]));const o=new i.ConvexPolyhedron({faces:t,vertices:r});return o}(s):function(e){const{vertices:t,indices:n}=e,r=new i.Trimesh(t,n);return r}(s),{shape:h,offset:a,orientation:u}}}}]);